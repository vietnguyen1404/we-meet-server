---
description: 'Generate scaffold folder structures for new projects based on existing documentation. Uses `/docs/*.md` files to understand conventions and patterns, prompting for missing information instead of exploring codebases. Supports multiple project types with detailed blueprints, visualization options, naming conventions, and templates for consistent code organization.'
agent: 'setup-greenfield'
---

# Scaffold Folder Structure Blueprint Generator

## Configuration Variables

${PROJECT_NAME=""}
<!-- Name of the new project to scaffold -->

${PROJECT_TYPE=".NET|Java|React|Angular|Python|Node.js|Flutter|Other"}
<!-- Select primary technology -->

${INCLUDES_MICROSERVICES="true|false"}
<!-- Is this a microservices architecture? -->

${INCLUDES_FRONTEND="true|false"}
<!-- Does project include frontend components? -->

${IS_MONOREPO="true|false"}
<!-- Is this a monorepo with multiple projects? -->

${VISUALIZATION_STYLE="ASCII|Markdown List|Table"}
<!-- How to visualize the structure -->

${DEPTH_LEVEL="3"}
<!-- How many levels of folders to generate (1-5) -->

${INCLUDE_GENERATED_FOLDERS="false"}
<!-- Include auto-generated folders in scaffold -->

${INCLUDE_FILE_PATTERNS="true"}
<!-- Document file naming/location patterns -->

${INCLUDE_TEMPLATES="true"}
<!-- Include file/folder templates for new features -->

${OUTPUT_PATH="./scaffold"}
<!-- Path where scaffold structure will be generated -->

## Generated Prompt

"Generate a scaffold folder structure for a new ${PROJECT_TYPE} project named '${PROJECT_NAME}' at path '${OUTPUT_PATH}'. Base the scaffold on conventions and patterns documented in `/docs/*.md` files and create a comprehensive document at `/docs/folder-structure.md` that serves as a definitive guide for maintaining consistent code organization. Use the following approach:

### Phase 1: Documentation Analysis

First, search for and read relevant documentation files in the `/docs/` directory:

1. **Look for key documentation files**:
   - Files containing folder structure conventions and directory organization patterns
   - Architecture documentation describing project organization and design patterns
   - Technology stack documentation outlining framework-specific structures
   - Coding standards and conventions documentation for naming and organization rules
   - Project overview documentation showing setup and structural patterns
   - Any documentation files describing project layout, module organization, or development workflows

2. **Extract patterns from documentation**:
   - Folder naming conventions (case styles, prefixes, suffixes)
   - Directory hierarchy principles (by feature, by layer, by domain)
   - File placement rules and patterns
   - Technology-specific organizational patterns
   - Extension and scaling strategies

3. **Handle missing information**:
   - If critical information is not found in documentation, **prompt the user** for clarification
   - Do NOT explore the codebase or make assumptions
   - Ask specific questions about missing patterns or conventions
   - Wait for user input before proceeding with scaffold generation

### Phase 2: Scaffold Structure Design

Based on the documentation analysis and user-provided information, design the scaffold structure:

#### 1. Project Overview

Document the scaffold's organizational approach:

- Overall architectural principles for ${PROJECT_TYPE} projects
- Main organizational strategy (by feature, by layer, by domain, etc.)
- Structural patterns derived from documentation
- Rationale for the chosen structure

${IS_MONOREPO ?
"Explain how the monorepo structure will be organized and how projects will relate to each other." : ""}

${INCLUDES_MICROSERVICES ?
"Describe the microservices organization structure and service boundaries." : ""}

${INCLUDES_FRONTEND ?
"Document how frontend components will be structured and integrated." : ""}

#### 2. Directory Visualization

Generate the folder structure using ${VISUALIZATION_STYLE} format to depth level ${DEPTH_LEVEL}:

${VISUALIZATION_STYLE == "ASCII" ?
"Create an ASCII tree representation of the folder hierarchy." : ""}

${VISUALIZATION_STYLE == "Markdown List" ?
"Use nested markdown lists to represent the folder hierarchy." : ""}

${VISUALIZATION_STYLE == "Table" ?
"Create a table with columns: Path | Purpose | Content Types | Conventions." : ""}

${INCLUDE_GENERATED_FOLDERS ?
"Include folders that will be generated by build tools (e.g., bin/, obj/, node_modules/)." :
"Exclude auto-generated folders. Focus on source-controlled directories only."}

#### 3. Directory Purpose Documentation

For each directory in the scaffold, document its purpose and usage based on patterns from documentation:

${(PROJECT_TYPE == ".NET") ?
"**For .NET Projects**:

- **Solution Organization**:
  - Project grouping and relationships
  - Solution folder patterns
  - Multi-targeting configurations

- **Project Structure**:
  - Internal folder hierarchy
  - Source code organization
  - Resource file placement
  - Dependency management

- **Domain/Feature Organization**:
  - Business domain separation
  - Feature module boundaries
  - Domain-driven design patterns

- **Layer Organization**:
  - Controllers, Services, Repositories structure
  - Layer dependencies and interactions
  - Cross-cutting concerns placement

- **Configuration Management**:
  - Configuration file locations
  - Environment-specific settings
  - Secret and sensitive data handling

- **Test Project Structure**:
  - Test project naming and placement
  - Test categorization (unit, integration, e2e)
  - Test data and mock organization" : ""}

${(PROJECT_TYPE == "React" || PROJECT_TYPE == "Angular") ?
"**For ${PROJECT_TYPE} Projects**:

${(PROJECT_TYPE == "React" || PROJECT_TYPE == "Angular") ?
"**For ${PROJECT_TYPE} Projects**:

- **Component Organization**:
  - Component folder structure
  - Grouping strategies (by feature, type, domain)
  - Shared vs. feature-specific components
  - Component file patterns (component, styles, tests)

- **State Management**:
  - State-related file organization
  - Global store structure
  - Context/provider patterns
  - Local state conventions

- **Routing Organization**:
  - Route definition locations
  - Page/view component structure
  - Nested route patterns
  - Route guards/middleware placement

- **API Integration**:
  - API client organization
  - Service layer structure
  - Data fetching hooks/services
  - API type definitions

- **Asset Management**:
  - Static resource organization
  - Image and media files
  - Font and icon placement
  - Public asset structure

- **Style Organization**:
  - CSS/SCSS file structure
  - Theme and design tokens
  - Style module patterns
  - Global vs. component styles" : ""}

${(PROJECT_TYPE == "Java") ?
"**For Java Projects**:

- **Package Hierarchy**:
  - Package naming conventions
  - Domain vs. technical packages
  - Package organization strategies

- **Build Tool Structure**:
  - Maven/Gradle organization
  - Module structure
  - Resource directories

- **Source Organization**:
  - Main source structure
  - Test source structure
  - Resource placement" : ""}

${(PROJECT_TYPE == "Python") ?
"**For Python Projects**:

- **Module Organization**:
  - Package structure
  - Module naming conventions
  - Import path patterns

- **Application Structure**:
  - Entry point locations
  - Core application logic
  - Utility and helper modules

- **Configuration and Resources**:
  - Config file placement
  - Static resources
  - Data files" : ""}

${(PROJECT_TYPE == "Node.js") ?
"**For Node.js Projects**:

- **Module Organization**:
  - CommonJS vs. ESM structure
  - Internal module patterns
  - Package organization

- **Application Structure**:
  - Server entry points
  - Route/controller organization
  - Middleware placement
  - Service layer structure

- **Configuration Management**:
  - Config file locations
  - Environment variables
  - Secret management" : ""}

${(PROJECT_TYPE == "Flutter") ?
"**For Flutter Projects**:

- **Application Structure**:
  - Widget organization
  - Screen/page structure
  - Feature modules

- **State Management**:
  - State provider structure
  - Model organization
  - Business logic placement

- **Asset Organization**:
  - Image assets
  - Font files
  - Configuration files" : ""}

#### 4. File Placement Patterns

${INCLUDE_FILE_PATTERNS ?
"Document the rules for where different file types should be placed:

- **Configuration Files**:
  - Root-level configuration placement
  - Environment-specific config locations
  - Tool-specific configuration files

- **Model/Entity Definitions**:
  - Domain model locations
  - DTO placement patterns
  - Schema definition files
  - Type definition locations

- **Business Logic**:
  - Service implementation placement
  - Business rule organization
  - Utility and helper functions
  - Domain logic encapsulation

- **Interface/Contract Definitions**:
  - Interface file locations
  - Abstract class placement
  - Protocol/contract definitions
  - API contract files

- **Test Files**:
  - Unit test placement (co-located vs. separate)
  - Integration test locations
  - E2E test organization
  - Test utility and mock placement
  - Test data file locations

- **Documentation Files**:
  - API documentation placement
  - Component documentation
  - README distribution strategy
  - Architecture decision records (ADRs)" :
"Document basic file placement rules based on documentation."}

#### 5. Naming Conventions

Document naming and organizational conventions from documentation:

- **File Naming Patterns**:
  - Case conventions (PascalCase, camelCase, kebab-case, snake_case)
  - Type-based prefixes and suffixes
  - File extension patterns
  - Special naming for specific file types

- **Folder Naming Patterns**:
  - Directory naming conventions
  - Hierarchical naming strategies
  - Plural vs. singular naming rules
  - Special folder markers (__, .prefix, etc.)

- **Namespace/Module Patterns**:
  - Namespace to folder mapping
  - Module naming conventions
  - Import/export patterns
  - Internal vs. public API separation

- **Code Organization Patterns**:
  - Co-location strategies
  - Feature encapsulation approaches
  - Cross-cutting concern organization
  - Shared code placement

#### 6. Development Workflow Guidance

Provide guidance for working with the scaffold:

- **Entry Points**:
  - Main application entry point location
  - Configuration starting points
  - Initial setup file locations

- **Common Development Tasks**:
  - Where to add new features
  - How to extend existing functionality
  - Where to place new tests
  - Configuration modification locations
  - Adding new dependencies

- **Dependency Flow**:
  - Allowed dependency directions
  - Import/reference patterns
  - Circular dependency prevention
  - Layer isolation rules

#### 7. Initial File Templates

Generate essential starter files based on documentation patterns:

- **Root-level Files**:
  - README.md with project setup instructions
  - .gitignore with appropriate exclusions
  - Configuration files (package.json, requirements.txt, etc.)
  - Build/task configuration files
  - Docker files (if applicable)

- **Core Application Files**:
  - Main entry point with basic setup
  - Initial configuration files
  - Basic routing or navigation setup (if applicable)
  - Example feature structure

${INCLUDE_TEMPLATES ?
"#### 8. Extension Templates

Provide reusable templates for common additions:

- **New Feature Template**:
  - Complete folder structure for a feature
  - Required files and their basic content
  - Integration points with existing structure
  - Naming conventions to follow

- **New Component Template** (for UI projects):
  - Component file structure
  - Test file setup
  - Style file organization
  - Documentation template

- **New Service Template** (for backend projects):
  - Service class structure
  - Interface/contract definition
  - Test setup
  - Configuration registration

- **New Module Template** (for modular projects):
  - Module folder structure
  - Entry point setup
  - Configuration files
  - Public API definition" : ""}

### Phase 3: Scaffold Generation

Generate the actual scaffold structure:

1. **Create Directory Structure**:
   - Generate all folders as defined in the blueprint
   - Maintain proper nesting and hierarchy
   - Apply naming conventions consistently

2. **Generate Starter Files**:
   - Create essential configuration files
   - Generate entry point files with basic setup
   - Add README files with context
   - Include .gitkeep for empty directories that should be tracked

3. **Documentation**:
   - Create STRUCTURE.md documenting the scaffold
   - Include usage instructions
   - Document extension patterns
   - List key conventions and rules

4. **Validation**:
   - Verify structure matches documentation patterns
   - Check naming consistency
   - Ensure all required files are present
   - Validate against project type requirements

### Output Format

Provide the scaffold as:
1. A visual representation (using ${VISUALIZATION_STYLE} format)
2. A list of files and directories to create
3. Content for essential starter files
4. A STRUCTURE.md file documenting the scaffold

### Missing Information Protocol

If critical information is not available in documentation:

1. **Identify the gap**: Clearly state what information is missing
2. **Ask specific questions**: Request the needed details from the user
3. **Provide context**: Explain why this information is needed
4. **Suggest defaults**: Offer reasonable defaults based on common practices
5. **Wait for response**: Do not proceed with scaffold generation until clarification is received

Example questions to ask:
- 'The documentation doesn't specify [X]. Would you like to use [default] or provide a custom [X]?'
- 'I couldn't find information about [Y] in the docs. What convention should I follow for [Y]?'
- 'Should I include [Z] in the scaffold? This wasn't mentioned in the documentation.'

"

